// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	domains "inc-nlp-service-echo/business_module/domains"

	gorm "github.com/jinzhu/gorm"

	mock "github.com/stretchr/testify/mock"

	uuid "github.com/satori/go.uuid"
)

// INlpRecordRepository is an autogenerated mock type for the INlpRecordRepository type
type INlpRecordRepository struct {
	mock.Mock
}

// BulkDeleteByIDs provides a mock function with given fields: IDs
func (_m *INlpRecordRepository) BulkDeleteByIDs(IDs []string) *gorm.DB {
	ret := _m.Called(IDs)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func([]string) *gorm.DB); ok {
		r0 = rf(IDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// BulkInsert provides a mock function with given fields: Domains, bulkCount
func (_m *INlpRecordRepository) BulkInsert(Domains []interface{}, bulkCount int) error {
	ret := _m.Called(Domains, bulkCount)

	var r0 error
	if rf, ok := ret.Get(0).(func([]interface{}, int) error); ok {
		r0 = rf(Domains, bulkCount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Count provides a mock function with given fields:
func (_m *INlpRecordRepository) Count() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// CountByKeywordMinhash provides a mock function with given fields: KeywordMinhash
func (_m *INlpRecordRepository) CountByKeywordMinhash(KeywordMinhash uint32) int64 {
	ret := _m.Called(KeywordMinhash)

	var r0 int64
	if rf, ok := ret.Get(0).(func(uint32) int64); ok {
		r0 = rf(KeywordMinhash)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// CountByStoryIDs provides a mock function with given fields: storyIDs
func (_m *INlpRecordRepository) CountByStoryIDs(storyIDs []string) int64 {
	ret := _m.Called(storyIDs)

	var r0 int64
	if rf, ok := ret.Get(0).(func([]string) int64); ok {
		r0 = rf(storyIDs)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// Delete provides a mock function with given fields:
func (_m *INlpRecordRepository) Delete() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// DeleteByID provides a mock function with given fields: id
func (_m *INlpRecordRepository) DeleteByID(id uuid.UUID) *gorm.DB {
	ret := _m.Called(id)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(uuid.UUID) *gorm.DB); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// FindByKeyword provides a mock function with given fields: keyword
func (_m *INlpRecordRepository) FindByKeyword(keyword string) []domains.NlpRecordDomain {
	ret := _m.Called(keyword)

	var r0 []domains.NlpRecordDomain
	if rf, ok := ret.Get(0).(func(string) []domains.NlpRecordDomain); ok {
		r0 = rf(keyword)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domains.NlpRecordDomain)
		}
	}

	return r0
}

// FindByKeywordMinhash provides a mock function with given fields: keywordMinhash
func (_m *INlpRecordRepository) FindByKeywordMinhash(keywordMinhash uint32) []domains.NlpRecordDomain {
	ret := _m.Called(keywordMinhash)

	var r0 []domains.NlpRecordDomain
	if rf, ok := ret.Get(0).(func(uint32) []domains.NlpRecordDomain); ok {
		r0 = rf(keywordMinhash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domains.NlpRecordDomain)
		}
	}

	return r0
}

// FindByKeywordMinhashAndStoryID provides a mock function with given fields: keywordMinhash, storyID
func (_m *INlpRecordRepository) FindByKeywordMinhashAndStoryID(keywordMinhash uint32, storyID []uuid.UUID) []domains.NlpRecordDomain {
	ret := _m.Called(keywordMinhash, storyID)

	var r0 []domains.NlpRecordDomain
	if rf, ok := ret.Get(0).(func(uint32, []uuid.UUID) []domains.NlpRecordDomain); ok {
		r0 = rf(keywordMinhash, storyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domains.NlpRecordDomain)
		}
	}

	return r0
}

// Pagination provides a mock function with given fields: PageIndex, Limit
func (_m *INlpRecordRepository) Pagination(PageIndex int, Limit int) []domains.NlpRecordDomain {
	ret := _m.Called(PageIndex, Limit)

	var r0 []domains.NlpRecordDomain
	if rf, ok := ret.Get(0).(func(int, int) []domains.NlpRecordDomain); ok {
		r0 = rf(PageIndex, Limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domains.NlpRecordDomain)
		}
	}

	return r0
}

// PaginationByKeywordMinhash provides a mock function with given fields: KeywordMinhash, PageIndex, Limit
func (_m *INlpRecordRepository) PaginationByKeywordMinhash(KeywordMinhash uint32, PageIndex int, Limit int) []domains.NlpRecordDomain {
	ret := _m.Called(KeywordMinhash, PageIndex, Limit)

	var r0 []domains.NlpRecordDomain
	if rf, ok := ret.Get(0).(func(uint32, int, int) []domains.NlpRecordDomain); ok {
		r0 = rf(KeywordMinhash, PageIndex, Limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domains.NlpRecordDomain)
		}
	}

	return r0
}

// PaginationByStoryIDs provides a mock function with given fields: storyIDs, PageIndex, Limit
func (_m *INlpRecordRepository) PaginationByStoryIDs(storyIDs []string, PageIndex int, Limit int) []domains.NlpRecordDomain {
	ret := _m.Called(storyIDs, PageIndex, Limit)

	var r0 []domains.NlpRecordDomain
	if rf, ok := ret.Get(0).(func([]string, int, int) []domains.NlpRecordDomain); ok {
		r0 = rf(storyIDs, PageIndex, Limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domains.NlpRecordDomain)
		}
	}

	return r0
}

// Save provides a mock function with given fields: Domain
func (_m *INlpRecordRepository) Save(Domain *domains.NlpRecordDomain) {
	_m.Called(Domain)
}

// UpdateByID provides a mock function with given fields: Domain
func (_m *INlpRecordRepository) UpdateByID(Domain *domains.NlpRecordDomain) {
	_m.Called(Domain)
}
